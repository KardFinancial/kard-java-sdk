/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.kard.api.resources.users.rewards.requests;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.kard.api.core.ObjectMappers;
import com.kard.api.resources.commons.types.CategoryOption;
import com.kard.api.resources.commons.types.State;
import com.kard.api.resources.users.rewards.types.LocationSortOptions;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = GetLocationsByUserRequest.Builder.class)
public final class GetLocationsByUserRequest {
    private final Optional<List<LocationSortOptions>> sort;

    private final Optional<List<String>> include;

    private final Optional<Integer> pageSize;

    private final Optional<String> pageAfter;

    private final Optional<String> pageBefore;

    private final Optional<String> filterName;

    private final Optional<String> filterCity;

    private final Optional<String> filterZipCode;

    private final Optional<State> filterState;

    private final Optional<CategoryOption> filterCategory;

    private final Optional<Double> filterLongitude;

    private final Optional<Double> filterLatitude;

    private final Optional<Integer> filterRadius;

    private final Map<String, Object> additionalProperties;

    private GetLocationsByUserRequest(
            Optional<List<LocationSortOptions>> sort,
            Optional<List<String>> include,
            Optional<Integer> pageSize,
            Optional<String> pageAfter,
            Optional<String> pageBefore,
            Optional<String> filterName,
            Optional<String> filterCity,
            Optional<String> filterZipCode,
            Optional<State> filterState,
            Optional<CategoryOption> filterCategory,
            Optional<Double> filterLongitude,
            Optional<Double> filterLatitude,
            Optional<Integer> filterRadius,
            Map<String, Object> additionalProperties) {
        this.sort = sort;
        this.include = include;
        this.pageSize = pageSize;
        this.pageAfter = pageAfter;
        this.pageBefore = pageBefore;
        this.filterName = filterName;
        this.filterCity = filterCity;
        this.filterZipCode = filterZipCode;
        this.filterState = filterState;
        this.filterCategory = filterCategory;
        this.filterLongitude = filterLongitude;
        this.filterLatitude = filterLatitude;
        this.filterRadius = filterRadius;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return If provided, response will be sorted by the specified fields
     */
    @JsonProperty("sort")
    public Optional<List<LocationSortOptions>> getSort() {
        return sort;
    }

    /**
     * @return CSV list of included resources in the response (e.g &quot;offers,categories&quot;). Allowed values are <code>offers</code> and <code>categories</code>.
     */
    @JsonProperty("include")
    public Optional<List<String>> getInclude() {
        return include;
    }

    @JsonProperty("page[size]")
    public Optional<Integer> getPageSize() {
        return pageSize;
    }

    @JsonProperty("page[after]")
    public Optional<String> getPageAfter() {
        return pageAfter;
    }

    @JsonProperty("page[before]")
    public Optional<String> getPageBefore() {
        return pageBefore;
    }

    @JsonProperty("filter[name]")
    public Optional<String> getFilterName() {
        return filterName;
    }

    @JsonProperty("filter[city]")
    public Optional<String> getFilterCity() {
        return filterCity;
    }

    @JsonProperty("filter[zipCode]")
    public Optional<String> getFilterZipCode() {
        return filterZipCode;
    }

    @JsonProperty("filter[state]")
    public Optional<State> getFilterState() {
        return filterState;
    }

    @JsonProperty("filter[category]")
    public Optional<CategoryOption> getFilterCategory() {
        return filterCategory;
    }

    @JsonProperty("filter[longitude]")
    public Optional<Double> getFilterLongitude() {
        return filterLongitude;
    }

    @JsonProperty("filter[latitude]")
    public Optional<Double> getFilterLatitude() {
        return filterLatitude;
    }

    @JsonProperty("filter[radius]")
    public Optional<Integer> getFilterRadius() {
        return filterRadius;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof GetLocationsByUserRequest && equalTo((GetLocationsByUserRequest) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(GetLocationsByUserRequest other) {
        return sort.equals(other.sort)
                && include.equals(other.include)
                && pageSize.equals(other.pageSize)
                && pageAfter.equals(other.pageAfter)
                && pageBefore.equals(other.pageBefore)
                && filterName.equals(other.filterName)
                && filterCity.equals(other.filterCity)
                && filterZipCode.equals(other.filterZipCode)
                && filterState.equals(other.filterState)
                && filterCategory.equals(other.filterCategory)
                && filterLongitude.equals(other.filterLongitude)
                && filterLatitude.equals(other.filterLatitude)
                && filterRadius.equals(other.filterRadius);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.sort,
                this.include,
                this.pageSize,
                this.pageAfter,
                this.pageBefore,
                this.filterName,
                this.filterCity,
                this.filterZipCode,
                this.filterState,
                this.filterCategory,
                this.filterLongitude,
                this.filterLatitude,
                this.filterRadius);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<List<LocationSortOptions>> sort = Optional.empty();

        private Optional<List<String>> include = Optional.empty();

        private Optional<Integer> pageSize = Optional.empty();

        private Optional<String> pageAfter = Optional.empty();

        private Optional<String> pageBefore = Optional.empty();

        private Optional<String> filterName = Optional.empty();

        private Optional<String> filterCity = Optional.empty();

        private Optional<String> filterZipCode = Optional.empty();

        private Optional<State> filterState = Optional.empty();

        private Optional<CategoryOption> filterCategory = Optional.empty();

        private Optional<Double> filterLongitude = Optional.empty();

        private Optional<Double> filterLatitude = Optional.empty();

        private Optional<Integer> filterRadius = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(GetLocationsByUserRequest other) {
            sort(other.getSort());
            include(other.getInclude());
            pageSize(other.getPageSize());
            pageAfter(other.getPageAfter());
            pageBefore(other.getPageBefore());
            filterName(other.getFilterName());
            filterCity(other.getFilterCity());
            filterZipCode(other.getFilterZipCode());
            filterState(other.getFilterState());
            filterCategory(other.getFilterCategory());
            filterLongitude(other.getFilterLongitude());
            filterLatitude(other.getFilterLatitude());
            filterRadius(other.getFilterRadius());
            return this;
        }

        /**
         * <p>If provided, response will be sorted by the specified fields</p>
         */
        @JsonSetter(value = "sort", nulls = Nulls.SKIP)
        public Builder sort(Optional<List<LocationSortOptions>> sort) {
            this.sort = sort;
            return this;
        }

        public Builder sort(List<LocationSortOptions> sort) {
            this.sort = Optional.ofNullable(sort);
            return this;
        }

        public Builder sort(LocationSortOptions sort) {
            this.sort = Optional.of(Collections.singletonList(sort));
            return this;
        }

        /**
         * <p>CSV list of included resources in the response (e.g &quot;offers,categories&quot;). Allowed values are <code>offers</code> and <code>categories</code>.</p>
         */
        @JsonSetter(value = "include", nulls = Nulls.SKIP)
        public Builder include(Optional<List<String>> include) {
            this.include = include;
            return this;
        }

        public Builder include(List<String> include) {
            this.include = Optional.ofNullable(include);
            return this;
        }

        public Builder include(String include) {
            this.include = Optional.of(Collections.singletonList(include));
            return this;
        }

        @JsonSetter(value = "page[size]", nulls = Nulls.SKIP)
        public Builder pageSize(Optional<Integer> pageSize) {
            this.pageSize = pageSize;
            return this;
        }

        public Builder pageSize(Integer pageSize) {
            this.pageSize = Optional.ofNullable(pageSize);
            return this;
        }

        @JsonSetter(value = "page[after]", nulls = Nulls.SKIP)
        public Builder pageAfter(Optional<String> pageAfter) {
            this.pageAfter = pageAfter;
            return this;
        }

        public Builder pageAfter(String pageAfter) {
            this.pageAfter = Optional.ofNullable(pageAfter);
            return this;
        }

        @JsonSetter(value = "page[before]", nulls = Nulls.SKIP)
        public Builder pageBefore(Optional<String> pageBefore) {
            this.pageBefore = pageBefore;
            return this;
        }

        public Builder pageBefore(String pageBefore) {
            this.pageBefore = Optional.ofNullable(pageBefore);
            return this;
        }

        @JsonSetter(value = "filter[name]", nulls = Nulls.SKIP)
        public Builder filterName(Optional<String> filterName) {
            this.filterName = filterName;
            return this;
        }

        public Builder filterName(String filterName) {
            this.filterName = Optional.ofNullable(filterName);
            return this;
        }

        @JsonSetter(value = "filter[city]", nulls = Nulls.SKIP)
        public Builder filterCity(Optional<String> filterCity) {
            this.filterCity = filterCity;
            return this;
        }

        public Builder filterCity(String filterCity) {
            this.filterCity = Optional.ofNullable(filterCity);
            return this;
        }

        @JsonSetter(value = "filter[zipCode]", nulls = Nulls.SKIP)
        public Builder filterZipCode(Optional<String> filterZipCode) {
            this.filterZipCode = filterZipCode;
            return this;
        }

        public Builder filterZipCode(String filterZipCode) {
            this.filterZipCode = Optional.ofNullable(filterZipCode);
            return this;
        }

        @JsonSetter(value = "filter[state]", nulls = Nulls.SKIP)
        public Builder filterState(Optional<State> filterState) {
            this.filterState = filterState;
            return this;
        }

        public Builder filterState(State filterState) {
            this.filterState = Optional.ofNullable(filterState);
            return this;
        }

        @JsonSetter(value = "filter[category]", nulls = Nulls.SKIP)
        public Builder filterCategory(Optional<CategoryOption> filterCategory) {
            this.filterCategory = filterCategory;
            return this;
        }

        public Builder filterCategory(CategoryOption filterCategory) {
            this.filterCategory = Optional.ofNullable(filterCategory);
            return this;
        }

        @JsonSetter(value = "filter[longitude]", nulls = Nulls.SKIP)
        public Builder filterLongitude(Optional<Double> filterLongitude) {
            this.filterLongitude = filterLongitude;
            return this;
        }

        public Builder filterLongitude(Double filterLongitude) {
            this.filterLongitude = Optional.ofNullable(filterLongitude);
            return this;
        }

        @JsonSetter(value = "filter[latitude]", nulls = Nulls.SKIP)
        public Builder filterLatitude(Optional<Double> filterLatitude) {
            this.filterLatitude = filterLatitude;
            return this;
        }

        public Builder filterLatitude(Double filterLatitude) {
            this.filterLatitude = Optional.ofNullable(filterLatitude);
            return this;
        }

        @JsonSetter(value = "filter[radius]", nulls = Nulls.SKIP)
        public Builder filterRadius(Optional<Integer> filterRadius) {
            this.filterRadius = filterRadius;
            return this;
        }

        public Builder filterRadius(Integer filterRadius) {
            this.filterRadius = Optional.ofNullable(filterRadius);
            return this;
        }

        public GetLocationsByUserRequest build() {
            return new GetLocationsByUserRequest(
                    sort,
                    include,
                    pageSize,
                    pageAfter,
                    pageBefore,
                    filterName,
                    filterCity,
                    filterZipCode,
                    filterState,
                    filterCategory,
                    filterLongitude,
                    filterLatitude,
                    filterRadius,
                    additionalProperties);
        }
    }
}
