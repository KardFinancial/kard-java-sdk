/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.kard.api.resources.files.requests;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.kard.api.core.ObjectMappers;
import com.kard.api.resources.files.types.FileType;
import com.kard.api.resources.files.types.FilesMetadataSortOptions;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = GetFilesMetadataRequest.Builder.class)
public final class GetFilesMetadataRequest {
    private final Optional<List<FilesMetadataSortOptions>> sort;

    private final Optional<String> filterDateFrom;

    private final Optional<String> filterDateTo;

    private final Optional<FileType> filterFileType;

    private final Optional<Integer> pageSize;

    private final Optional<String> pageAfter;

    private final Optional<String> pageBefore;

    private final Map<String, Object> additionalProperties;

    private GetFilesMetadataRequest(
            Optional<List<FilesMetadataSortOptions>> sort,
            Optional<String> filterDateFrom,
            Optional<String> filterDateTo,
            Optional<FileType> filterFileType,
            Optional<Integer> pageSize,
            Optional<String> pageAfter,
            Optional<String> pageBefore,
            Map<String, Object> additionalProperties) {
        this.sort = sort;
        this.filterDateFrom = filterDateFrom;
        this.filterDateTo = filterDateTo;
        this.filterFileType = filterFileType;
        this.pageSize = pageSize;
        this.pageAfter = pageAfter;
        this.pageBefore = pageBefore;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return If provided, response will be sorted by the specified fields. Defaults to descending sentDate, equivalent to &quot;-sentDate&quot;
     */
    @JsonProperty("sort")
    public Optional<List<FilesMetadataSortOptions>> getSort() {
        return sort;
    }

    /**
     * @return Start date for filtering files (format ISO8601). If not provided, defaults to current date minus 1 month.
     */
    @JsonProperty("filter[dateFrom]")
    public Optional<String> getFilterDateFrom() {
        return filterDateFrom;
    }

    /**
     * @return End date for filtering files (format ISO8601). If not provided, defaults to current date.
     */
    @JsonProperty("filter[dateTo]")
    public Optional<String> getFilterDateTo() {
        return filterDateTo;
    }

    /**
     * @return The document file type.
     */
    @JsonProperty("filter[fileType]")
    public Optional<FileType> getFilterFileType() {
        return filterFileType;
    }

    /**
     * @return Number of items per page. Defaults to 10 if not specified and maximum value allowed 100 items per page.
     */
    @JsonProperty("page[size]")
    public Optional<Integer> getPageSize() {
        return pageSize;
    }

    /**
     * @return Cursor for forward pagination (next page).
     */
    @JsonProperty("page[after]")
    public Optional<String> getPageAfter() {
        return pageAfter;
    }

    /**
     * @return Cursor for backward pagination (previous page).
     */
    @JsonProperty("page[before]")
    public Optional<String> getPageBefore() {
        return pageBefore;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof GetFilesMetadataRequest && equalTo((GetFilesMetadataRequest) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(GetFilesMetadataRequest other) {
        return sort.equals(other.sort)
                && filterDateFrom.equals(other.filterDateFrom)
                && filterDateTo.equals(other.filterDateTo)
                && filterFileType.equals(other.filterFileType)
                && pageSize.equals(other.pageSize)
                && pageAfter.equals(other.pageAfter)
                && pageBefore.equals(other.pageBefore);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.sort,
                this.filterDateFrom,
                this.filterDateTo,
                this.filterFileType,
                this.pageSize,
                this.pageAfter,
                this.pageBefore);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<List<FilesMetadataSortOptions>> sort = Optional.empty();

        private Optional<String> filterDateFrom = Optional.empty();

        private Optional<String> filterDateTo = Optional.empty();

        private Optional<FileType> filterFileType = Optional.empty();

        private Optional<Integer> pageSize = Optional.empty();

        private Optional<String> pageAfter = Optional.empty();

        private Optional<String> pageBefore = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(GetFilesMetadataRequest other) {
            sort(other.getSort());
            filterDateFrom(other.getFilterDateFrom());
            filterDateTo(other.getFilterDateTo());
            filterFileType(other.getFilterFileType());
            pageSize(other.getPageSize());
            pageAfter(other.getPageAfter());
            pageBefore(other.getPageBefore());
            return this;
        }

        /**
         * <p>If provided, response will be sorted by the specified fields. Defaults to descending sentDate, equivalent to &quot;-sentDate&quot;</p>
         */
        @JsonSetter(value = "sort", nulls = Nulls.SKIP)
        public Builder sort(Optional<List<FilesMetadataSortOptions>> sort) {
            this.sort = sort;
            return this;
        }

        public Builder sort(List<FilesMetadataSortOptions> sort) {
            this.sort = Optional.ofNullable(sort);
            return this;
        }

        public Builder sort(FilesMetadataSortOptions sort) {
            this.sort = Optional.of(Collections.singletonList(sort));
            return this;
        }

        /**
         * <p>Start date for filtering files (format ISO8601). If not provided, defaults to current date minus 1 month.</p>
         */
        @JsonSetter(value = "filter[dateFrom]", nulls = Nulls.SKIP)
        public Builder filterDateFrom(Optional<String> filterDateFrom) {
            this.filterDateFrom = filterDateFrom;
            return this;
        }

        public Builder filterDateFrom(String filterDateFrom) {
            this.filterDateFrom = Optional.ofNullable(filterDateFrom);
            return this;
        }

        /**
         * <p>End date for filtering files (format ISO8601). If not provided, defaults to current date.</p>
         */
        @JsonSetter(value = "filter[dateTo]", nulls = Nulls.SKIP)
        public Builder filterDateTo(Optional<String> filterDateTo) {
            this.filterDateTo = filterDateTo;
            return this;
        }

        public Builder filterDateTo(String filterDateTo) {
            this.filterDateTo = Optional.ofNullable(filterDateTo);
            return this;
        }

        /**
         * <p>The document file type.</p>
         */
        @JsonSetter(value = "filter[fileType]", nulls = Nulls.SKIP)
        public Builder filterFileType(Optional<FileType> filterFileType) {
            this.filterFileType = filterFileType;
            return this;
        }

        public Builder filterFileType(FileType filterFileType) {
            this.filterFileType = Optional.ofNullable(filterFileType);
            return this;
        }

        /**
         * <p>Number of items per page. Defaults to 10 if not specified and maximum value allowed 100 items per page.</p>
         */
        @JsonSetter(value = "page[size]", nulls = Nulls.SKIP)
        public Builder pageSize(Optional<Integer> pageSize) {
            this.pageSize = pageSize;
            return this;
        }

        public Builder pageSize(Integer pageSize) {
            this.pageSize = Optional.ofNullable(pageSize);
            return this;
        }

        /**
         * <p>Cursor for forward pagination (next page).</p>
         */
        @JsonSetter(value = "page[after]", nulls = Nulls.SKIP)
        public Builder pageAfter(Optional<String> pageAfter) {
            this.pageAfter = pageAfter;
            return this;
        }

        public Builder pageAfter(String pageAfter) {
            this.pageAfter = Optional.ofNullable(pageAfter);
            return this;
        }

        /**
         * <p>Cursor for backward pagination (previous page).</p>
         */
        @JsonSetter(value = "page[before]", nulls = Nulls.SKIP)
        public Builder pageBefore(Optional<String> pageBefore) {
            this.pageBefore = pageBefore;
            return this;
        }

        public Builder pageBefore(String pageBefore) {
            this.pageBefore = Optional.ofNullable(pageBefore);
            return this;
        }

        public GetFilesMetadataRequest build() {
            return new GetFilesMetadataRequest(
                    sort,
                    filterDateFrom,
                    filterDateTo,
                    filterFileType,
                    pageSize,
                    pageAfter,
                    pageBefore,
                    additionalProperties);
        }

        public Builder additionalProperty(String key, Object value) {
            this.additionalProperties.put(key, value);
            return this;
        }

        public Builder additionalProperties(Map<String, Object> additionalProperties) {
            this.additionalProperties.putAll(additionalProperties);
            return this;
        }
    }
}
